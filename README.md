# Garbled Circuits & Oblivious Transfer

This project implements a **garbled circuit protocol** along with supporting cryptographic components.  
It was developed as part of a practical project on secure computation.

The implementation includes:
- AES encryption in CTR mode
- A garbled circuit implementation using the **Point-and-Permute** optimization
- Unit tests using `pytest`

---

# Installation

Install the required Python libraries with:

```bash
pip install -r requirements.txt
```

---

# Running the Tests

To run all tests:

```bash
python -m pytest test/
```

You can also run tests for a specific module, for example:

```bash
python -m pytest test/garbled_circuit
```

---

# Garbled Circuit Implementation
**Author:** Mohamed BEN EL MOSTAPHA

## Overview

The implementation is located in the `garbled_circuit` package.

### `ctr.py`

This file implements **AES encryption in Counter (CTR) mode** using the `pycryptodome` library.

---

### `garbler.py`

This file implements a variation of garbled circuits called **Point and Permute**.

Unlike the classical version, which uses a MAC to verify correct decryption, this approach uses the **last bit of wire labels** to determine the exact position to decrypt in the truth table.

Example:

```
Label 1 : 101001....1
Label 2 : 101000....0
```

Decryption position:

```
10 (binary) = 2 (decimal)
```

---

# Implementation Details

## Counter Mode Encryption

```python
encrypt_ctr(key: int, message: int, nonce: int)
```

Parameters:

- `key` – a 128-bit encryption key
- `message` – a message of arbitrary length
- `nonce` – a random value

How it works:

1. The message is split into 128-bit blocks (with padding if necessary).
2. Block `i` is XORed with a mask.
3. The mask is generated by encrypting `nonce + i` using AES.

---

# Garbled Circuits

### `generate_wire_labels(circuit: CircuitCombinatoire)`

Given a circuit, generates a table that associates each node with:

```
(label0, label1)
```

- `label0` represents logical value **0**
- `label1` represents logical value **1**

Labels are random values up to 128 bits.

Output nodes are assigned:

```
(0, 1)
```

Important property:

```
label0 & 1 != label1 & 1
```

This property is required for the **Point-and-Permute** technique.

---

### `get_index_from_input_labels(label_input_list)`

Given a list of labels, computes the index used to select the correct encrypted entry in the truth table.

The index is built by concatenating the **last bit of each label**.

---

### `encrypt_output_label_with_input_labels(...)`

Encrypts an output label using the input labels.

Process:

1. Take the list of input labels.
2. Encrypt the output label multiple times.
3. Each encryption uses one label as a key.
4. The output of the previous encryption becomes the message of the next.

Encryption uses `encrypt_ctr`.

---

### `decrypt_encrypted_output_label_with_input_labels(...)`

Performs the same operations as encryption but with the labels in **reverse order** to recover the original label.

---

### `binary_to_label_list(binary_list, label_tuples)`

Converts a binary input list into a list of labels.

Example:

```
0 -> label0
1 -> label1
```

---

### `get_input_possibilities(node: Node)`

Returns the list of possible input combinations depending on the node type.

---

### `garble(circuit: CircuitCombinatoire, wire_labels, nonce)`

Builds the garbled circuit.

For each node:

1. Retrieve its input nodes
2. Initialize a table representing its truth table
3. Compute all possible input combinations

For each possibility:

1. Compute the output value
2. Convert it to the corresponding label
3. Convert input values into labels
4. Encrypt the output label using the input labels
5. Store the encrypted value at the position computed with `get_index_from_input_labels`

The function returns a mapping between nodes and their garbled truth tables.

---

### `evaluate(...)`

Evaluates the garbled circuit.

`wire_values` is a dictionary mapping each node to its current value (label).

Requirements:

- Input nodes must already contain the correct labels.

For each node:

1. Retrieve the input labels
2. Compute the correct table index
3. Decrypt the corresponding entry
4. Store the resulting label as the node’s value

---

# Project Structure

```
garbled_circuit/
│
├── ctr.py
├── garbler.py
│
test/
├── garbled_circuit/
```
